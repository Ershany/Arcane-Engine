#include "arcpch.h"
#include "Texture.h"

namespace Arcane
{
	// TODO: Current Texture Copy implementation only copies the highest resolution mip (level 0)
	// This implementation is fine when the hardware generates the mips because our newly created texture will do the same
	// This only fails if the mip levels contain custom data that was generated by the hardware via glGenerateMipmap(...)
	Texture::Texture(const Texture &texture) : m_TextureId(0), m_TextureTarget(texture.GetTextureTarget()), m_Width(texture.GetWidth()), m_Height(texture.GetHeight()), m_TextureSettings(texture.GetTextureSettings()) {
		glGenTextures(1, &m_TextureId);
		Bind();

		glTexImage2D(m_TextureTarget, 0, m_TextureSettings.TextureFormat, m_Width, m_Height, 0, GL_RGB, GL_UNSIGNED_BYTE, nullptr);
		ApplyTextureSettings();
		glCopyImageSubData(texture.GetTextureId(), texture.GetTextureTarget(), 0, 0, 0, 0, m_TextureId, m_TextureTarget, 0, 0, 0, 0, m_Width, m_Height, 1);

		Unbind();
	}

	Texture::Texture(TextureSettings &settings) : m_TextureId(0), m_TextureTarget(0), m_Width(0), m_Height(0), m_TextureSettings(settings) {}

	Texture::~Texture() {
		glDeleteTextures(1, &m_TextureId);
	}

	void Texture::ApplyTextureSettings() {
		// Texture wrapping
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, m_TextureSettings.TextureWrapSMode);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, m_TextureSettings.TextureWrapTMode);
		if (m_TextureSettings.HasBorder) {
			glTexParameterfv(GL_TEXTURE_2D, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_TextureSettings.BorderColour));
		}

		// Texture filtering
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, m_TextureSettings.TextureMinificationFilterMode);
		glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, m_TextureSettings.TextureMagnificationFilterMode);

		// Mipmapping
		if (m_TextureSettings.HasMips) {
			glGenerateMipmap(GL_TEXTURE_2D);
			glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_LOD_BIAS, m_TextureSettings.MipBias);
		}

		// Anisotropic filtering (TODO: Move the anistropyAmount calculation to Defs.h to avoid querying the OpenGL driver everytime)
		float maxAnisotropy;
		glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
		float anistropyAmount = glm::min<float>(maxAnisotropy, m_TextureSettings.TextureAnisotropyLevel);
		glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropyAmount);
	}

	void Texture::Generate2DTexture(unsigned int width, unsigned int height, GLenum dataFormat, GLenum pixelDataType, const void *data) {
		m_TextureTarget = GL_TEXTURE_2D;
		m_Width = width;
		m_Height = height;

		// If GL_NONE is specified, set the texture format to the data format
		if (m_TextureSettings.TextureFormat == GL_NONE) {
			m_TextureSettings.TextureFormat = dataFormat;
		}
		// Check if the texture is SRGB, if so change the texture format
		if (m_TextureSettings.IsSRGB) {
			switch (dataFormat) {
			case GL_RGB: m_TextureSettings.TextureFormat = GL_SRGB; break;
			case GL_RGBA: m_TextureSettings.TextureFormat = GL_SRGB_ALPHA; break;
			}
		}

		glGenTextures(1, &m_TextureId);
		Bind();

		glTexImage2D(GL_TEXTURE_2D, 0, m_TextureSettings.TextureFormat, width, height, 0, dataFormat, pixelDataType, data);
		ApplyTextureSettings();

		Unbind();
	}

	void Texture::Generate2DMultisampleTexture(unsigned int width, unsigned int height) {
		// Multisampled textures do not support mips or filtering/wrapping options
		m_TextureTarget = GL_TEXTURE_2D_MULTISAMPLE;
		m_Width = width;
		m_Height = height;

		glGenTextures(1, &m_TextureId);
		Bind();
		glTexImage2DMultisample(GL_TEXTURE_2D_MULTISAMPLE, MSAA_SAMPLE_AMOUNT, m_TextureSettings.TextureFormat, m_Width, m_Height, GL_TRUE);
		Unbind();
	}

	void Texture::GenerateMips() {
		m_TextureSettings.HasMips = true;
		if (IsGenerated()) {
			Bind();
			glGenerateMipmap(m_TextureTarget);
		}
	}

	void Texture::Bind(int unit) {
		glActiveTexture(GL_TEXTURE0 + unit);
		glBindTexture(m_TextureTarget, m_TextureId);
	}

	void Texture::Unbind() {
		glBindTexture(m_TextureTarget, 0);
	}



	void Texture::SetTextureWrapS(GLenum textureWrapMode) {
		if (m_TextureSettings.TextureWrapSMode == textureWrapMode)
			return;

		m_TextureSettings.TextureWrapSMode = textureWrapMode;
		if (IsGenerated()) {
			glTexParameteri(m_TextureTarget, GL_TEXTURE_WRAP_S, m_TextureSettings.TextureWrapSMode);
		}
	}

	void Texture::SetTextureWrapT(GLenum textureWrapMode) {
		if (m_TextureSettings.TextureWrapTMode == textureWrapMode)
			return;

		m_TextureSettings.TextureWrapTMode = textureWrapMode;
		if (IsGenerated()) {
			glTexParameteri(m_TextureTarget, GL_TEXTURE_WRAP_T, m_TextureSettings.TextureWrapTMode);
		}
	}

	void Texture::SetHasBorder(bool hasBorder) {
		if (m_TextureSettings.HasBorder == hasBorder)
			return;

		m_TextureSettings.HasBorder = hasBorder;
		if (IsGenerated()) {
			glTexParameterfv(m_TextureTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_TextureSettings.BorderColour));
		}
	}

	void Texture::SetBorderColour(glm::vec4 &borderColour) {
		if (m_TextureSettings.BorderColour == borderColour || m_TextureSettings.HasBorder == false)
			return;

		m_TextureSettings.BorderColour = borderColour;
		if (IsGenerated()) {
			glTexParameterfv(m_TextureTarget, GL_TEXTURE_BORDER_COLOR, glm::value_ptr(m_TextureSettings.BorderColour));
		}
	}

	void Texture::SetTextureMinFilter(GLenum textureFilterMode) {
		if (m_TextureSettings.TextureMinificationFilterMode == textureFilterMode)
			return;

		m_TextureSettings.TextureMinificationFilterMode = textureFilterMode;
		if (IsGenerated()) {
			glTexParameteri(m_TextureTarget, GL_TEXTURE_MIN_FILTER, m_TextureSettings.TextureMinificationFilterMode);
		}
	}

	void Texture::SetTextureMagFilter(GLenum textureFilterMode) {
#ifdef ARC_DEV_BUILD
		// If mag filter mode exceeds GL_Linear (bilinear) report an error because it is useless to perform more expensive filtering with magnification
		if (textureFilterMode > GL_LINEAR)
			ARC_LOG_WARN("Texture's magnification filter exceeded bilinear filtering which won't result in any visual improvements and will just cost more");
#endif // ARC_DEV_BUILD

		if (m_TextureSettings.TextureMagnificationFilterMode == textureFilterMode)
			return;

		m_TextureSettings.TextureMagnificationFilterMode = textureFilterMode;
		if (IsGenerated()) {
			glTexParameteri(m_TextureTarget, GL_TEXTURE_MAG_FILTER, m_TextureSettings.TextureMagnificationFilterMode);
		}
	}

	void Texture::SetAnisotropicFilteringMode(float textureAnisotropyLevel) {
		if (m_TextureSettings.TextureAnisotropyLevel == textureAnisotropyLevel)
			return;

		m_TextureSettings.TextureAnisotropyLevel = textureAnisotropyLevel;
		if (IsGenerated()) {
			float maxAnisotropy;
			glGetFloatv(GL_MAX_TEXTURE_MAX_ANISOTROPY_EXT, &maxAnisotropy);
			float anistropyAmount = glm::min<float>(maxAnisotropy, m_TextureSettings.TextureAnisotropyLevel);
			glTexParameterf(m_TextureTarget, GL_TEXTURE_MAX_ANISOTROPY_EXT, anistropyAmount);
		}
	}

	void Texture::SetMipBias(int mipBias) {
		if (m_TextureSettings.MipBias == mipBias)
			return;

		m_TextureSettings.MipBias = mipBias;
		if (IsGenerated()) {
			glTexParameteri(m_TextureTarget, GL_TEXTURE_LOD_BIAS, m_TextureSettings.MipBias);
		}
	}

	void Texture::SetHasMips(bool hasMips) {
		if (m_TextureSettings.HasMips == hasMips)
			return;

		m_TextureSettings.HasMips = hasMips;
		if (IsGenerated() && hasMips == true) {
			glGenerateMipmap(m_TextureTarget);
		}
	}
}
